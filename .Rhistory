optimizer = torch$optim$Adamax(model$parameters(), lr = 0.001)
lambda1 = torch$tensor(0.0008)$to(device)
lambda2 = torch$tensor(0.001)$to(device)
DT =
torch$utils$data$TensorDataset(torch$tensor(XX, dtype = torch$float32)$to(device),
torch$tensor(Y[1:split_border,,drop=FALSE], dtype = torch$float32)$to(device))
DL = torch$utils$data$DataLoader(DT, batch_size = 50L, shuffle = TRUE, pin_memory = FALSE)
for(e in 1:epochs) {
DATA = reticulate::iterate(DL)
for(b in 1:length(DATA)){
x = DATA[[b]][[0]]
y = DATA[[b]][[1]]
pred = model(x)
loss = torch$nn$functional$mse_loss(pred, y, reduce = FALSE)$mean(0L)$sum()
K = reticulate::iterate( model$parameters() )
loss = loss$add(torch$cat(sapply(K, function(k) torch$norm( k ,p = 1L)$reshape(c(1L, 1L))))$sum()$mul(lambda1))
loss = loss$add(torch$cat(sapply(K, function(k) torch$norm( k ,p = 2L)$reshape(c(1L, 1L))))$sum()$mul(lambda2))
loss$backward()
optimizer$step()
optimizer$zero_grad()
}
if(e %% 10 ==0) cat(paste0("Epoch: ",e," Loss: ", loss$item(), "\n"))
}
epochs = 2L
for(e in 1:epochs) {
DATA = reticulate::iterate(DL)
for(b in 1:length(DATA)){
x = DATA[[b]][[0]]
y = DATA[[b]][[1]]
pred = model(x)
loss = torch$nn$functional$mse_loss(pred, y, reduce = FALSE)$mean(0L)$sum()
K = reticulate::iterate( model$parameters() )
loss = loss$add(torch$cat(sapply(K, function(k) torch$norm( k ,p = 1L)$reshape(c(1L, 1L))))$sum()$mul(lambda1))
loss = loss$add(torch$cat(sapply(K, function(k) torch$norm( k ,p = 2L)$reshape(c(1L, 1L))))$sum()$mul(lambda2))
loss$backward()
optimizer$step()
optimizer$zero_grad()
}
if(e %% 10 ==0) cat(paste0("Epoch: ",e," Loss: ", loss$item(), "\n"))
}
dim(X)
XX = array(X[(split_border+1L):nrow(X),], dim = c(length((split_border+1L):nrow(X)), 200L,2L))
XT = torch$tensor(XX,
dtype = torch$float32)$to(device)
Pred = model(XT)$data$cpu()$numpy()
torch$cuda$empty_cache()
Pred
cor(Y[(split_border+1L):nrow(X),,drop=FALSE][,1], Pred[,1])
cor(Y[(split_border+1L):nrow(X),,drop=FALSE][,2], Pred[,2])
rm(model)
gc()
torch$cuda$empty_cache()
N
N[is.na(N)]
N[is.na(N)] = 0
N
parameter =
data.frame(
par = c("distP", "b0_e","b1_recr", "b2_recr", "b1_g","b2_g"),
default = c(0.01, 0.5, 20, -0.2, 3, -0.1),
min = c(0, 0, 0, -5, 0, -5),
max = c(0.2, 1, 50, 0, 10,0)
)
data_simulate = expand.grid(factor(c(0,1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0,1)))[-1,]
data_simulate = sapply(as.data.frame(data_simulate), function(r) as.integer(r) - 1L)
colnames(data_simulate) = c("distP",
"b0_e",
"b1_recr",
"b2_recr",
"b1_g",
"b2_g")
data_simulate = as.data.frame(data_simulate)
clusterEvalQ(cl, {library(sjSDM);source("R/functions.R")})
library(sjSDM)
library(reticulate)
library(parallel)
source("R/functions.R")
cl = makeCluster(8L)
nodes = unlist(parallel::clusterEvalQ(cl, paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')))
parameter =
data.frame(
par = c("distP", "b0_e","b1_recr", "b2_recr", "b1_g","b2_g"),
default = c(0.01, 0.5, 20, -0.2, 3, -0.1),
min = c(0, 0, 0, -5, 0, -5),
max = c(0.2, 1, 50, 0, 10,0)
)
data_simulate = expand.grid(factor(c(0,1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0,1)))[-1,]
data_simulate = sapply(as.data.frame(data_simulate), function(r) as.integer(r) - 1L)
colnames(data_simulate) = c("distP",
"b0_e",
"b1_recr",
"b2_recr",
"b1_g",
"b2_g")
data_simulate = as.data.frame(data_simulate)
clusterEvalQ(cl, {library(sjSDM);source("R/functions.R")})
parallel::clusterExport(cl, varlist = ls(envir = .GlobalEnv))
results = parSapply(cl, 1:12, function(KK) {
myself = paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')
dist = cbind(nodes,0:3)
dev = as.integer(as.numeric(dist[which(dist[,1] %in% myself, arr.ind = TRUE), 2]))
source("R/functions.R")
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 1000L, device = as.integer(dev), split =0.7)
result = list(list(results = results, data = samples))
names(result) = paste0(names(which(unlist(tmp) == 1, arr.ind = TRUE)), collapse = "+")
return(result)
})
results$b1_recr$results$obs
cor(results$b1_recr$results$obs, results$b1_recr$results$pred)
results$b1_recr$results$pred
cor(results$distP$results$obs, results$distP$results$pred)
results$distP$results$pred
data_simulate
KK = 1
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
data = (abind::abind(data, along = 0L))
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
data
data[1,]
data[2,]
data[3,]
data[4,]
# Function to simulate Beverton-Holt model
beverton_holt <- function(
N0, timesteps, spinup = 0, sample_interval = 1,
b0_e = 0.0, b1_e = 0.0,
b0_k = 100, b1_k = 0.3,
b1_g = 0.0, b2_g = 0,
b0_r = 1, b1_recr = 0.1, b2_recr = -0.001, opt_x1 = 1,
distP = 0.01, Nrep = 1
) {
out_df <- data.frame(
rep = integer(), t = integer(), N=numeric(), x1=numeric(), K=numeric(), g=numeric(),
recr = numeric(), recr_mean = numeric(), disturbance = integer(),
actualR = numeric())
for(rep_i in 1:Nrep){
# Create vectors to store N sizes and time steps
N <- numeric(timesteps)
# Set initial N size
N[1] <- N0
recr = 1
for (t in 2:timesteps) {
#if(t < cc_range[1])
x1 = b0_e + rnorm(1,0,.02)
x1[x1>1] = 1
x1[x1<0] = 0
#x1 = plogis(b0_e + b1_e*(t - opt_x1)^2+runif(1,0,1))
K = b0_k + b1_k * x1
g = plogis(b1_g * x1 + b2_g*N[t-1])*2
#recr_mean = b0_r*exp(b1_recr*x1 + b2_recr*N[t] - 1)
# Simulate N dynamics
disturbance = rbinom(1,1,1-distP)
N[t] <- (g * N[t-1]) / (1 + (N[t-1] / K))*disturbance
recr = max(recr, 1)
K_r = 10
g_recr = plogis(b0_r + b1_recr*x1+b2_recr*N[t])*2
if(g_recr < 0.0001) g_recr = 0
recr_mean = (g_recr * recr) / (1 + (recr / K_r))
recr = rpois(1, recr_mean)
N[t] = N[t] + recr
out_df <- rbind(
out_df,
data.frame(rep=rep_i, t=t, N=N[t], x1, K, g, recr_mean, recr,disturbance, actualR = N[t-1]/N[t])
)
}
}
sample_vec <- seq(spinup, timesteps-1, sample_interval)
# Return the N sizes and time steps
return(out_df[sample_vec,])
}
library(Rcpp)
sourceCpp("R/beverton-hold.cpp")
beverton_holt
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N
E
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 1000L, device = as.integer(dev), split =0.7)
dev = 1
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 1000L, device = as.integer(dev), split =0.7)
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
results$obs
cor(results$obs, results$pred)
parallel::stopCluster(cl)
library(sjSDM)
library(reticulate)
library(parallel)
library(Rcpp)
sourceCpp("R/beverton-hold.cpp")
source("R/functions.R")
cl = makeCluster(8L)
nodes = unlist(parallel::clusterEvalQ(cl, paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')))
clusterEvalQ(cl, {library(sjSDM);source("R/functions.R")})
clusterEvalQ(cl, {library(Rcpp);sourceCpp("R/beverton-hold.cpp")})
parameter =
data.frame(
par = c("distP", "b0_e","b1_recr", "b2_recr", "b1_g","b2_g"),
default = c(0.01, 0.5, 20, -0.2, 3, -0.1),
min = c(0, 0, 0, -5, 0, -5),
max = c(0.2, 1, 50, 0, 10,0)
)
data_simulate = expand.grid(factor(c(0,1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0,1)))[-1,]
data_simulate = sapply(as.data.frame(data_simulate), function(r) as.integer(r) - 1L)
colnames(data_simulate) = c("distP",
"b0_e",
"b1_recr",
"b2_recr",
"b1_g",
"b2_g")
data_simulate = as.data.frame(data_simulate)
parallel::clusterExport(cl, varlist = ls(envir = .GlobalEnv))
results = parSapply(cl, 1:nrow(data_simulate), function(KK) {
myself = paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')
dist = cbind(nodes,0:3)
dev = as.integer(as.numeric(dist[which(dist[,1] %in% myself, arr.ind = TRUE), 2]))
source("R/functions.R")
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
result = list(list(results = results, data = samples))
names(result) = paste0(names(which(unlist(tmp) == 1, arr.ind = TRUE)), collapse = "+")
return(result)
})
clusterEvalQ(cl, {library(Rcpp);sourceCpp("R/beverton-hold.cpp")})
results = parSapply(cl, 1:nrow(data_simulate), function(KK) {
sourceCpp("R/beverton-hold.cpp")
myself = paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')
dist = cbind(nodes,0:3)
dev = as.integer(as.numeric(dist[which(dist[,1] %in% myself, arr.ind = TRUE), 2]))
source("R/functions.R")
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
result = list(list(results = results, data = samples))
names(result) = paste0(names(which(unlist(tmp) == 1, arr.ind = TRUE)), collapse = "+")
return(result)
})
results$distP
results$distP$results$pred
results$distP$results$obs
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results$pred
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results$obs

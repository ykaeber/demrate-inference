timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 1000L, device = as.integer(dev), split =0.7)
dev = 1
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 1000L, device = as.integer(dev), split =0.7)
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
results$obs
cor(results$obs, results$pred)
parallel::stopCluster(cl)
library(sjSDM)
library(reticulate)
library(parallel)
library(Rcpp)
sourceCpp("R/beverton-hold.cpp")
source("R/functions.R")
cl = makeCluster(8L)
nodes = unlist(parallel::clusterEvalQ(cl, paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')))
clusterEvalQ(cl, {library(sjSDM);source("R/functions.R")})
clusterEvalQ(cl, {library(Rcpp);sourceCpp("R/beverton-hold.cpp")})
parameter =
data.frame(
par = c("distP", "b0_e","b1_recr", "b2_recr", "b1_g","b2_g"),
default = c(0.01, 0.5, 20, -0.2, 3, -0.1),
min = c(0, 0, 0, -5, 0, -5),
max = c(0.2, 1, 50, 0, 10,0)
)
data_simulate = expand.grid(factor(c(0,1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0, 1)),
factor(c(0,1)))[-1,]
data_simulate = sapply(as.data.frame(data_simulate), function(r) as.integer(r) - 1L)
colnames(data_simulate) = c("distP",
"b0_e",
"b1_recr",
"b2_recr",
"b1_g",
"b2_g")
data_simulate = as.data.frame(data_simulate)
parallel::clusterExport(cl, varlist = ls(envir = .GlobalEnv))
results = parSapply(cl, 1:nrow(data_simulate), function(KK) {
myself = paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')
dist = cbind(nodes,0:3)
dev = as.integer(as.numeric(dist[which(dist[,1] %in% myself, arr.ind = TRUE), 2]))
source("R/functions.R")
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
result = list(list(results = results, data = samples))
names(result) = paste0(names(which(unlist(tmp) == 1, arr.ind = TRUE)), collapse = "+")
return(result)
})
clusterEvalQ(cl, {library(Rcpp);sourceCpp("R/beverton-hold.cpp")})
results = parSapply(cl, 1:nrow(data_simulate), function(KK) {
sourceCpp("R/beverton-hold.cpp")
myself = paste(Sys.info()[['nodename']], Sys.getpid(), sep='-')
dist = cbind(nodes,0:3)
dev = as.integer(as.numeric(dist[which(dist[,1] %in% myself, arr.ind = TRUE), 2]))
source("R/functions.R")
tmp = (data_simulate[KK, ])
data =
lapply(1:100, function(i) {
distP = ifelse(tmp$distP,     runif(1, 0, 0.2), 0.01)
b0_e = ifelse(tmp$b0_e,       runif(1, 0, 1.0), 0.5)
b1_recr = ifelse(tmp$b1_recr, runif(1, 0, 50), 20)
b2_recr = ifelse(tmp$b2_recr, runif(1, -5, 0.0), -0.2)
b1_g = ifelse(tmp$b1_g,       runif(1, 0, 1.0), 3)
b2_g = ifelse(tmp$b2_g,       runif(1, -5, 0), -0.1)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 210,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
samples = data[, c(which(unlist(tmp) > 0.5, arr.ind = TRUE)),drop=FALSE]
samples = data.frame(samples)
colnames(samples) = names(which(unlist(tmp) == 1, arr.ind = TRUE))
if(sum(unlist(tmp)) != 6) data = data[, -c(which(unlist(tmp) != 1, arr.ind = TRUE))]
results = train_function(data, n_response = length(which(unlist(tmp) == 1, arr.ind = TRUE)), epochs = 10L, device = as.integer(dev), split =0.7)
result = list(list(results = results, data = samples))
names(result) = paste0(names(which(unlist(tmp) == 1, arr.ind = TRUE)), collapse = "+")
return(result)
})
results$distP
results$distP$results$pred
results$distP$results$obs
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results$pred
results$`distP+b0_e+b1_recr+b2_recr+b1_g+b2_g`$results$obs
cl = makeCluster(60L)
library(parallel)
library(Rcpp)
library(BayesianTools)
sourceCpp("R/beverton-hold.cpp")
sourceCpp("library/beverton-hold.cpp")
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs$N)**2)/500
})
return(-mean(ll))
}
cl = makeCluster(60L)
clusterEvalQ(cl, {Rcpp::sourceCpp("library/beverton-hold.cpp")})
parallel::clusterExport(cl, varlist = ls(envir = .GlobalEnv))
clusterEvalQ(cl, {Rcpp::sourceCpp("library/beverton-hold.cpp")})
data =
lapply(1:3000, function(i) {
distP = runif(1, 0, 0.2)
b0_e = runif(1, 0, 1.0)
b1_recr = runif(1, 0, 50)
b2_recr = runif(1, -5, 0.0)
b1_g = runif(1, 0, 1.0)
b2_g = runif(1, -5, 0)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N,
E
))
})
data = (abind::abind(data, along = 0L))
dim(data)
data =
lapply(1:3000, function(i) {
distP = runif(1, 0, 0.2)
b0_e = runif(1, 0, 1.0)
b1_recr = runif(1, 0, 50)
b2_recr = runif(1, -5, 0.0)
b1_g = runif(1, 0, 1.0)
b2_g = runif(1, -5, 0)
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = b0_e,
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = b1_g,
b2_g = b2_g,
b0_r = 30,
b1_recr = b1_recr,
b2_recr = b2_recr,
distP = distP,
Nrep = 1,
opt_x1 = 250)
N = data_tmp$N
E = data_tmp$x1
N[is.na(N)] = 0
return(c(distP,
b0_e,
b1_recr,
b2_recr,
b1_g,
b2_g,
N
))
})
data = (abind::abind(data, along = 0L))
dim(data)
KK = 1
obs = data[KK, -(1:6)]
true_pars = data[KK, 1:6]
library(BayesianTools)
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs$N)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 50000))
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 50000))
parallel::clusterExport(cl, varlist = ls(envir = .GlobalEnv))
clusterEvalQ(cl, {library(BayesianTools);Rcpp::sourceCpp("library/beverton-hold.cpp")})
results = parSapply(cl, 1:nrow(data), function(KK) {
obs = data[KK, -(1:6)]
true_pars = data[KK, 1:6]
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 500))
inferred = MAP(res, start = 50)$par
return(cbind(inferred, true_pars))
})
results = parSapply(cl, 1:30, function(KK) {
obs = data[KK, -(1:6)]
true_pars = data[KK, 1:6]
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 500))
inferred = MAP(res, start = 50)$par
return(cbind(inferred, true_pars))
})
results
dim(results)
results = parLapply(cl, 1:30, function(KK) {
obs = data[KK, -(1:6)]
true_pars = data[KK, 1:6]
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 500))
inferred = MAP(res, start = 50)$par
return(cbind(inferred, true_pars))
})
results
abind::abind(results)
results = abind::abind(results)
dim(results)
results = parLapply(cl, 1:30, function(KK) {
obs = data[KK, -(1:6)]
true_pars = data[KK, 1:6]
logLik = function(par) {
ll =
replicate(50, {
data_tmp =  beverton_holt(N0 = 10,
timesteps = 510,
spinup = 10L,
b0_e = par[2],
b1_e = 0.0,
b0_k = 100,
b1_k = 4.9,
b1_g = par[5],
b2_g = par[6],
b0_r = 30,
b1_recr = par[3],
b2_recr = par[4],
distP = par[1],
Nrep = 1,
opt_x1 = 250)$N
sum((data_tmp-obs)**2)/500
})
return(-mean(ll))
}
bs = createBayesianSetup(logLik, prior = createUniformPrior(c(0,0,0,-5,0,-5), c(0.2, 1.0, 50, 0.0, 1.0, 0)))
res = runMCMC(bs, settings = list(iterations = 500))
inferred = MAP(res, start = 50)$par
return(cbind(inferred, true_pars))
})
results = abind::abind(results, along = 0L)
resukts
resukts
dim(results)
plot(results[,1,])
plot(results[,2,])
plot(results[,3,])
plot(results[,4,])
plot(results[,5,])
plot(results[,6,])
plot(results[,3,])
results = readRDS("results/MCMC_3000.RDS")
abind::abind(results, along = 0L)
results = abind::abind(results, along = 0L)
dim(results)
sapply(1:6, function(i) cor(results[,i,]) )
sapply(1:6, function(i) cor(results[,i,1], results[,i,2]) )
plot(results[,1,1], results[,1,2])
plot(results[,2,1], results[,2,2])
plot(results[,3,1], results[,3,2])
plot(results[,4,1], results[,4,2])
plot(results[,5,1], results[,5,2])
res = readRDS("results/results_10000.RDS")
lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman")))
res = readRDS("results/MCMC_3000.RDS")
abind::abind(res, along = 0L)
res = abind::abind(res, along = 0L)
dim(res)
sapply(1:6, function(i) cor(results[,i,1], results[,i,2]) )
res = readRDS("results/results_2000.RDS")
lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman")))
res = readRDS("results/results_10000.RDS")
lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman")))
res = readRDS("results/results_2000.RDS")
lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman")))
unlist(lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman"))))
res = readRDS("results/results_10000.RDS")
d1 = unlist(lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman"))))
res = readRDS("results/results_2000.RDS")
d2 = unlist(lapply(res, function(r) sapply(1:ncol(r$results$obs), function(i) cor(r$results$obs[,i], r$results$pred[,i], method = "spearman"))))
plot(d1, d2)
abline( c(0, 1))
